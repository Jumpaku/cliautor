# Code generated by github.com/Jumpaku/cyamli v1.1.5, DO NOT EDIT.

from dataclasses import dataclass
import typing


@dataclass
class CLI_Validate_Input:
    opt_help: bool = False
    opt_schema_path: str = ""
    
    
    pass


class CLI_Validate:
    
    FUNC: typing.Callable[[None,list[str],CLI_Validate_Input,Exception],None] = None


def resolve_CLI_Validate_Input(rest_args: list[str])->CLI_Validate_Input:
    input = CLI_Validate_Input()
    arguments = []
    for i, arg in enumerate(rest_args):
        if arg == "--":
            arguments += rest_args[i+1:]
            break
        if not arg.startswith("-"):
            arguments.append(arg)
            continue
        split = arg.split("=", 1)
        opt_name, assign = split[0], len(split) > 1
        
        if opt_name == "-help" or opt_name == "-h":
            if not assign:
                split.append("True")
                
            input.opt_help = parse_value(bool, split[1])
            continue
        
        if opt_name == "-schema-path":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_schema_path = parse_value(str, split[1])
            continue
        
        raise Exception("unsupported option " + opt_name)
    
    return input


@dataclass
class CLI_List_Input:
    opt_help: bool = False
    opt_schema_path: str = ""
    
    
    pass


class CLI_List:
    
    FUNC: typing.Callable[[None,list[str],CLI_List_Input,Exception],None] = None


def resolve_CLI_List_Input(rest_args: list[str])->CLI_List_Input:
    input = CLI_List_Input()
    arguments = []
    for i, arg in enumerate(rest_args):
        if arg == "--":
            arguments += rest_args[i+1:]
            break
        if not arg.startswith("-"):
            arguments.append(arg)
            continue
        split = arg.split("=", 1)
        opt_name, assign = split[0], len(split) > 1
        
        if opt_name == "-help" or opt_name == "-h":
            if not assign:
                split.append("True")
                
            input.opt_help = parse_value(bool, split[1])
            continue
        
        if opt_name == "-schema-path":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_schema_path = parse_value(str, split[1])
            continue
        
        raise Exception("unsupported option " + opt_name)
    
    return input


@dataclass
class CLI_GeneratePython3_Input:
    opt_help: bool = False
    opt_out_path: str = ""
    opt_schema_path: str = ""
    
    
    pass


class CLI_GeneratePython3:
    
    FUNC: typing.Callable[[None,list[str],CLI_GeneratePython3_Input,Exception],None] = None


def resolve_CLI_GeneratePython3_Input(rest_args: list[str])->CLI_GeneratePython3_Input:
    input = CLI_GeneratePython3_Input()
    arguments = []
    for i, arg in enumerate(rest_args):
        if arg == "--":
            arguments += rest_args[i+1:]
            break
        if not arg.startswith("-"):
            arguments.append(arg)
            continue
        split = arg.split("=", 1)
        opt_name, assign = split[0], len(split) > 1
        
        if opt_name == "-help" or opt_name == "-h":
            if not assign:
                split.append("True")
                
            input.opt_help = parse_value(bool, split[1])
            continue
        
        if opt_name == "-out-path":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_out_path = parse_value(str, split[1])
            continue
        
        if opt_name == "-schema-path":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_schema_path = parse_value(str, split[1])
            continue
        
        raise Exception("unsupported option " + opt_name)
    
    return input


@dataclass
class CLI_GenerateGolang_Input:
    opt_help: bool = False
    opt_out_path: str = ""
    opt_package: str = "main"
    opt_schema_path: str = ""
    
    
    pass


class CLI_GenerateGolang:
    
    FUNC: typing.Callable[[None,list[str],CLI_GenerateGolang_Input,Exception],None] = None


def resolve_CLI_GenerateGolang_Input(rest_args: list[str])->CLI_GenerateGolang_Input:
    input = CLI_GenerateGolang_Input()
    arguments = []
    for i, arg in enumerate(rest_args):
        if arg == "--":
            arguments += rest_args[i+1:]
            break
        if not arg.startswith("-"):
            arguments.append(arg)
            continue
        split = arg.split("=", 1)
        opt_name, assign = split[0], len(split) > 1
        
        if opt_name == "-help" or opt_name == "-h":
            if not assign:
                split.append("True")
                
            input.opt_help = parse_value(bool, split[1])
            continue
        
        if opt_name == "-out-path":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_out_path = parse_value(str, split[1])
            continue
        
        if opt_name == "-package":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_package = parse_value(str, split[1])
            continue
        
        if opt_name == "-schema-path":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_schema_path = parse_value(str, split[1])
            continue
        
        raise Exception("unsupported option " + opt_name)
    
    return input


@dataclass
class CLI_GenerateDocs_Input:
    opt_all: bool = False
    opt_format: str = "text"
    opt_help: bool = False
    opt_out_path: str = ""
    opt_schema_path: str = ""
    
    arg_subcommands: tuple[str,...] = tuple[str,...]()
    
    pass


class CLI_GenerateDocs:
    
    FUNC: typing.Callable[[None,list[str],CLI_GenerateDocs_Input,Exception],None] = None


def resolve_CLI_GenerateDocs_Input(rest_args: list[str])->CLI_GenerateDocs_Input:
    input = CLI_GenerateDocs_Input()
    arguments = []
    for i, arg in enumerate(rest_args):
        if arg == "--":
            arguments += rest_args[i+1:]
            break
        if not arg.startswith("-"):
            arguments.append(arg)
            continue
        split = arg.split("=", 1)
        opt_name, assign = split[0], len(split) > 1
        
        if opt_name == "-all" or opt_name == "-a":
            if not assign:
                split.append("True")
                
            input.opt_all = parse_value(bool, split[1])
            continue
        
        if opt_name == "-format" or opt_name == "-f":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_format = parse_value(str, split[1])
            continue
        
        if opt_name == "-help" or opt_name == "-h":
            if not assign:
                split.append("True")
                
            input.opt_help = parse_value(bool, split[1])
            continue
        
        if opt_name == "-out-path":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_out_path = parse_value(str, split[1])
            continue
        
        if opt_name == "-schema-path":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_schema_path = parse_value(str, split[1])
            continue
        
        raise Exception("unsupported option " + opt_name)
    if len(arguments) <= 0 - 1:
        raise Exception("too few arguments")
    input.arg_subcommands = parse_value(tuple[str,...], *arguments[0:])
    
    return input


@dataclass
class CLI_GenerateDart_Input:
    opt_help: bool = False
    opt_out_path: str = ""
    opt_schema_path: str = ""
    
    
    pass


class CLI_GenerateDart:
    
    FUNC: typing.Callable[[None,list[str],CLI_GenerateDart_Input,Exception],None] = None


def resolve_CLI_GenerateDart_Input(rest_args: list[str])->CLI_GenerateDart_Input:
    input = CLI_GenerateDart_Input()
    arguments = []
    for i, arg in enumerate(rest_args):
        if arg == "--":
            arguments += rest_args[i+1:]
            break
        if not arg.startswith("-"):
            arguments.append(arg)
            continue
        split = arg.split("=", 1)
        opt_name, assign = split[0], len(split) > 1
        
        if opt_name == "-help" or opt_name == "-h":
            if not assign:
                split.append("True")
                
            input.opt_help = parse_value(bool, split[1])
            continue
        
        if opt_name == "-out-path":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_out_path = parse_value(str, split[1])
            continue
        
        if opt_name == "-schema-path":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_schema_path = parse_value(str, split[1])
            continue
        
        raise Exception("unsupported option " + opt_name)
    
    return input


@dataclass
class CLI_Generate_Input:
    opt_help: bool = False
    
    
    pass


class CLI_Generate:
    python3: CLI_GeneratePython3 = CLI_GeneratePython3()
    golang: CLI_GenerateGolang = CLI_GenerateGolang()
    docs: CLI_GenerateDocs = CLI_GenerateDocs()
    dart: CLI_GenerateDart = CLI_GenerateDart()
    
    FUNC: typing.Callable[[None,list[str],CLI_Generate_Input,Exception],None] = None


def resolve_CLI_Generate_Input(rest_args: list[str])->CLI_Generate_Input:
    input = CLI_Generate_Input()
    arguments = []
    for i, arg in enumerate(rest_args):
        if arg == "--":
            arguments += rest_args[i+1:]
            break
        if not arg.startswith("-"):
            arguments.append(arg)
            continue
        split = arg.split("=", 1)
        opt_name, assign = split[0], len(split) > 1
        
        if opt_name == "-help" or opt_name == "-h":
            if not assign:
                split.append("True")
                
            input.opt_help = parse_value(bool, split[1])
            continue
        
        raise Exception("unsupported option " + opt_name)
    
    return input


@dataclass
class CLI_Input:
    opt_help: bool = False
    opt_version: bool = False
    
    
    pass


class CLI:
    validate: CLI_Validate = CLI_Validate()
    list: CLI_List = CLI_List()
    generate: CLI_Generate = CLI_Generate()
    
    FUNC: typing.Callable[[None,list[str],CLI_Input,Exception],None] = None


def resolve_CLI_Input(rest_args: list[str])->CLI_Input:
    input = CLI_Input()
    arguments = []
    for i, arg in enumerate(rest_args):
        if arg == "--":
            arguments += rest_args[i+1:]
            break
        if not arg.startswith("-"):
            arguments.append(arg)
            continue
        split = arg.split("=", 1)
        opt_name, assign = split[0], len(split) > 1
        
        if opt_name == "-help" or opt_name == "-h":
            if not assign:
                split.append("True")
                
            input.opt_help = parse_value(bool, split[1])
            continue
        
        if opt_name == "-version" or opt_name == "-v":
            if not assign:
                split.append("True")
                
            input.opt_version = parse_value(bool, split[1])
            continue
        
        raise Exception("unsupported option " + opt_name)
    
    return input


def run(cli: CLI, args: list[str]):
    r = resolve_subcommand(args)
    subcommand_path, rest_args = r.subcommand, r.rest_args
    joined_subcommand = " ".join(subcommand_path)
    
    if joined_subcommand == "":
        if not cli.FUNC:
            raise Exception("unsupported subcommand \"" + "" + "\": cli.FUNC not assigned")
        ex: Exception = None
        input: CLI_Input = None
        try:
            input = resolve_CLI_Input(rest_args)
        except Exception as e:
            ex = e
        cli.FUNC(subcommand_path, input, ex)
    
    
    if joined_subcommand == "validate":
        if not cli.validate.FUNC:
            raise Exception("unsupported subcommand \"" + "validate" + "\": cli.validate.FUNC not assigned")
        ex: Exception = None
        input: CLI_Validate_Input = None
        try:
            input = resolve_CLI_Validate_Input(rest_args)
        except Exception as e:
            ex = e
        cli.validate.FUNC(subcommand_path, input, ex)
    
    if joined_subcommand == "list":
        if not cli.list.FUNC:
            raise Exception("unsupported subcommand \"" + "list" + "\": cli.list.FUNC not assigned")
        ex: Exception = None
        input: CLI_List_Input = None
        try:
            input = resolve_CLI_List_Input(rest_args)
        except Exception as e:
            ex = e
        cli.list.FUNC(subcommand_path, input, ex)
    
    if joined_subcommand == "generate python3":
        if not cli.generate.python3.FUNC:
            raise Exception("unsupported subcommand \"" + "generate python3" + "\": cli.generate.python3.FUNC not assigned")
        ex: Exception = None
        input: CLI_GeneratePython3_Input = None
        try:
            input = resolve_CLI_GeneratePython3_Input(rest_args)
        except Exception as e:
            ex = e
        cli.generate.python3.FUNC(subcommand_path, input, ex)
    
    if joined_subcommand == "generate golang":
        if not cli.generate.golang.FUNC:
            raise Exception("unsupported subcommand \"" + "generate golang" + "\": cli.generate.golang.FUNC not assigned")
        ex: Exception = None
        input: CLI_GenerateGolang_Input = None
        try:
            input = resolve_CLI_GenerateGolang_Input(rest_args)
        except Exception as e:
            ex = e
        cli.generate.golang.FUNC(subcommand_path, input, ex)
    
    if joined_subcommand == "generate docs":
        if not cli.generate.docs.FUNC:
            raise Exception("unsupported subcommand \"" + "generate docs" + "\": cli.generate.docs.FUNC not assigned")
        ex: Exception = None
        input: CLI_GenerateDocs_Input = None
        try:
            input = resolve_CLI_GenerateDocs_Input(rest_args)
        except Exception as e:
            ex = e
        cli.generate.docs.FUNC(subcommand_path, input, ex)
    
    if joined_subcommand == "generate dart":
        if not cli.generate.dart.FUNC:
            raise Exception("unsupported subcommand \"" + "generate dart" + "\": cli.generate.dart.FUNC not assigned")
        ex: Exception = None
        input: CLI_GenerateDart_Input = None
        try:
            input = resolve_CLI_GenerateDart_Input(rest_args)
        except Exception as e:
            ex = e
        cli.generate.dart.FUNC(subcommand_path, input, ex)
    
    if joined_subcommand == "generate":
        if not cli.generate.FUNC:
            raise Exception("unsupported subcommand \"" + "generate" + "\": cli.generate.FUNC not assigned")
        ex: Exception = None
        input: CLI_Generate_Input = None
        try:
            input = resolve_CLI_Generate_Input(rest_args)
        except Exception as e:
            ex = e
        cli.generate.FUNC(subcommand_path, input, ex)
    
    raise Exception("subcommand not found: " + joined_subcommand)

@dataclass
class ResolveSubcommandResult:
    subcommand: list[str]
    rest_args: list[str]


def resolve_subcommand(args: list[str])->ResolveSubcommandResult:
    if not args:
        raise Exception("command line arguments are too few")
    
    subcommand_set = {
        "",
        "validate","list","generate python3","generate golang","generate docs","generate dart","generate",
    }

    subcommand_path = []
    for arg in args[1:]:
        if arg == "--":
            break
        if " ".join(subcommand_path + [arg]) not in subcommand_set:
            break
        subcommand_path.append(arg)
    
    return ResolveSubcommandResult(subcommand_path, args[1+len(subcommand_path):])


def parse_value(typ, *str_values: str) -> typing.Union[str, bool, float, int, tuple[str, ...], tuple[bool, ...], tuple[float, ...], tuple[int, ...]]:
    try: 
        if typ == str:
            return str(str_values[0])
        if typ == bool:
            if str_values[0] in {"", "0", "f", "F", "FALSE", "false", "False"}:
                return False
            if str_values[0] in {"1", "t", "T", "TRUE", "true", "True"}:
                return True
            raise Exception("could not convert string to bool: '" + str_values[0] + "'")
        if typ == float:
            return float(str_values[0])
        if typ == int:
            return int(str_values[0], base=0)
        if typ == tuple[str,...]:
            return tuple([parse_value(str, s) for s in str_values])
        if typ == tuple[bool,...]:
            return tuple([parse_value(bool, s) for s in str_values])
        if typ == tuple[float,...]:
            return tuple([parse_value(float, s) for s in str_values])
        if typ == tuple[int,...]:
            return tuple([parse_value(int, s) for s in str_values])
        raise Exception("unsupported type")
    except Exception as e:
        e.add_note('fail to parse string value as ' + typ.__name__)
        raise


def get_doc(subcommand: list[str]) -> str:
    joined_subcommand = " ".join(subcommand)
    
    if joined_subcommand == "":
        return "cyamli (v1.1.5)\n\ncyamli\n\n    Description:\n        A command line tool to generate CLI for your app from YAML-based schema.\n\n    Syntax:\n        $ cyamli  [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -version[=<boolean>], -v[=<boolean>]  (default=false):\n            shows version of this app.\n\n    Subcommands:\n        generate:\n            holds subcommands to generate CLI code.\n\n        list:\n            shows subcommands\n\n        validate:\n            validates CLI schema.\n\n\n"
    
    
    if joined_subcommand == "validate":
        return "cyamli (v1.1.5)\n\ncyamli validate\n\n    Description:\n        validates CLI schema.\n\n    Syntax:\n        $ cyamli validate [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of validates subcommand.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"
    
    if joined_subcommand == "list":
        return "cyamli (v1.1.5)\n\ncyamli list\n\n    Description:\n        shows subcommands\n\n    Syntax:\n        $ cyamli list [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of list subcommand.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"
    
    if joined_subcommand == "generate python3":
        return "cyamli (v1.1.5)\n\ncyamli generate python3\n\n    Description:\n        generates CLI for your app written in Python3.\n\n    Syntax:\n        $ cyamli generate python3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of python3 subcommand.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"
    
    if joined_subcommand == "generate golang":
        return "cyamli (v1.1.5)\n\ncyamli generate golang\n\n    Description:\n        generates CLI for your app written in Go.\n\n    Syntax:\n        $ cyamli generate golang [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of golang subcommand.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"main\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"
    
    if joined_subcommand == "generate docs":
        return "cyamli (v1.1.5)\n\ncyamli generate docs\n\n    Description:\n        generates documentation for your CLI app.\n\n    Syntax:\n        $ cyamli generate docs [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -all[=<boolean>], -a[=<boolean>]  (default=false):\n            if specified then outputs documentation for all subcommands, otherwise in text format.\n\n        -format=<string>, -f=<string>  (default=\"text\"):\n            specifies output format of the documentation in text or markdown.\n\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of docs subcommand.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated documentation, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n    Arguments:\n        1. [<subcommands:string>]...\n            selects subcommand for which the documentation is output.\n\n\n"
    
    if joined_subcommand == "generate dart":
        return "cyamli (v1.1.5)\n\ncyamli generate dart\n\n    Description:\n        generates CLI for your app written in Dart.\n\n    Syntax:\n        $ cyamli generate dart [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of dart subcommand.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"
    
    if joined_subcommand == "generate":
        return "cyamli (v1.1.5)\n\ncyamli generate\n\n    Description:\n        holds subcommands to generate CLI code.\n\n    Syntax:\n        $ cyamli generate [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of generate subcommand.\n\n    Subcommands:\n        dart:\n            generates CLI for your app written in Dart.\n\n        docs:\n            generates documentation for your CLI app.\n\n        golang:\n            generates CLI for your app written in Go.\n\n        python3:\n            generates CLI for your app written in Python3.\n\n\n"
    
    raise Exception("subcommand not found: " + joined_subcommand)
