# Code generated by github.com/Jumpaku/cyamli v1.1.5, DO NOT EDIT.

from dataclasses import dataclass
import typing


@dataclass
class CLI_Sub_Input:
    opt_opt_boolean: bool = False
    opt_opt_integer: int = int(0)
    opt_opt_string: str = ""
    
    
    pass


FuncType_CLI_Sub = typing.Callable[[None,list[str],CLI_Sub_Input,Exception],None]
class CLI_Sub:
    
    FUNC: FuncType_CLI_Sub = None


def resolve_CLI_Sub_Input(rest_args: list[str])->CLI_Sub_Input:
    input = CLI_Sub_Input()
    arguments = []
    for i, arg in enumerate(rest_args):
        if arg == "--":
            arguments += rest_args[i+1:]
            break
        if not arg.startswith("-"):
            arguments.append(arg)
            continue
        split = arg.split("=", 1)
        opt_name, assign = split[0], len(split) > 1
        
        if opt_name == "-opt-boolean" or opt_name == "-b":
            if not assign:
                split.append("True")
                
            input.opt_opt_boolean = parse_value(bool, split[1])
            continue
        
        if opt_name == "-opt-integer" or opt_name == "-i":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_opt_integer = parse_value(int, split[1])
            continue
        
        if opt_name == "-opt-string" or opt_name == "-s":
            if not assign:
                raise Exception("value is not specified to option "+ opt_name)
                
            input.opt_opt_string = parse_value(str, split[1])
            continue
        
        raise Exception("unsupported option " + opt_name)
    
    return input



@dataclass
class CLI_Input:
    
    
    pass


FuncType_CLI = typing.Callable[[None,list[str],CLI_Input,Exception],None]
class CLI:
    sub: CLI_Sub = CLI_Sub()
    
    FUNC: FuncType_CLI = None


def resolve_CLI_Input(rest_args: list[str])->CLI_Input:
    input = CLI_Input()
    arguments = []
    for i, arg in enumerate(rest_args):
        if arg == "--":
            arguments += rest_args[i+1:]
            break
        if not arg.startswith("-"):
            arguments.append(arg)
            continue
        split = arg.split("=", 1)
        opt_name, assign = split[0], len(split) > 1
        
        raise Exception("unsupported option " + opt_name)
    
    return input


def run(cli: CLI, args: list[str]):
    r = resolve_subcommand(args)
    subcommand_path, rest_args = r.subcommand, r.rest_args
    joined_subcommand = " ".join(subcommand_path)
    
    if joined_subcommand == "":
        if not cli.FUNC:
            raise Exception("unsupported subcommand \"" + "" + "\": cli.FUNC not assigned")
        ex: Exception = None
        input: CLI_Input = None
        try:
            input = resolve_CLI_Input(rest_args)
        except Exception as e:
            ex = e
        cli.FUNC(subcommand_path, input, ex)
        return
    
    
    if joined_subcommand == "sub":
        if not cli.sub.FUNC:
            raise Exception("unsupported subcommand \"" + "sub" + "\": cli.sub.FUNC not assigned")
        ex: Exception = None
        input: CLI_Sub_Input = None
        try:
            input = resolve_CLI_Sub_Input(rest_args)
        except Exception as e:
            ex = e
        cli.sub.FUNC(subcommand_path, input, ex)
        return
    
    raise Exception("subcommand not found: " + joined_subcommand)

@dataclass
class ResolveSubcommandResult:
    subcommand: list[str]
    rest_args: list[str]


def resolve_subcommand(args: list[str])->ResolveSubcommandResult:
    if not args:
        raise Exception("command line arguments are too few")
    
    subcommand_set = {
        "",
        "sub",
    }

    subcommand_path = []
    for arg in args[1:]:
        if arg == "--":
            break
        if " ".join(subcommand_path + [arg]) not in subcommand_set:
            break
        subcommand_path.append(arg)
    
    return ResolveSubcommandResult(subcommand_path, args[1+len(subcommand_path):])


def parse_value(typ, *str_values: str) -> typing.Union[str, bool, float, int, tuple[str, ...], tuple[bool, ...], tuple[float, ...], tuple[int, ...]]:
    try: 
        if typ == str:
            return str(str_values[0])
        if typ == bool:
            if str_values[0] in {"", "0", "f", "F", "FALSE", "false", "False"}:
                return False
            if str_values[0] in {"1", "t", "T", "TRUE", "true", "True"}:
                return True
            raise Exception("could not convert string to bool: '" + str_values[0] + "'")
        if typ == float:
            return float(str_values[0])
        if typ == int:
            return int(str_values[0], base=0)
        if typ == tuple[str,...]:
            return tuple([parse_value(str, s) for s in str_values])
        if typ == tuple[bool,...]:
            return tuple([parse_value(bool, s) for s in str_values])
        if typ == tuple[float,...]:
            return tuple([parse_value(float, s) for s in str_values])
        if typ == tuple[int,...]:
            return tuple([parse_value(int, s) for s in str_values])
        raise Exception("unsupported type")
    except Exception as e:
        e.add_note('fail to parse string value as ' + typ.__name__)
        raise


def get_doc(subcommand: list[str]) -> str:
    joined_subcommand = " ".join(subcommand)
    
    if joined_subcommand == "":
        return "<program>\n\n<program>\n\n    Syntax:\n        $ <program> \n\n    Subcommands:\n        sub:\n\n\n"
    
    
    if joined_subcommand == "sub":
        return "<program>\n\n<program> sub\n\n    Syntax:\n        $ <program> sub [<option>]...\n\n    Options:\n        -opt-boolean[=<boolean>], -b[=<boolean>]  (default=false):\n\n        -opt-integer=<integer>, -i=<integer>  (default=0):\n\n        -opt-string=<string>, -s=<string>  (default=\"\"):\n\n\n"
    
    raise Exception("subcommand not found: " + joined_subcommand)
