// Code generated by cliautor 0.0.0, DO NOT EDIT.
package main

import (
	"fmt"
	"bytes"
	"strings"

	cliautor_schema "github.com/Jumpaku/cliautor/schema"
	cliautor_golang "github.com/Jumpaku/cliautor/golang"
)

func newSchema() *cliautor_schema.Schema {
	var schema, _ = cliautor_schema.Load(bytes.NewBufferString("name: example\nversion: v1.0.0\ndescription: this is an example command\noptions:\n  -option-a:\n    short: -a\n    description: a - this is an option for root command\n    type: string\n    default: abc\n  -option-b:\n    short: -b\n    description: b - this is an option for root command\n    type: integer\n    default: \"-123\"\n  -option-c:\n    short: -c\n    description: c - this is an option for root command\n    type: boolean\n    default: \"true\"\n  -option-d:\n    short: -d\n    description: d - this is an option for root command\n    type: float\n    default: \"-123.456\"\n  -option-e:\n    short: \"\"\n    description: \"\"\n    type: \"\"\n    default: \"\"\narguments:\n- name: arg_a\n  description: a - this is an argument for root command\n  type: string\n  variadic: false\n- name: arg_b\n  description: b - this is an argument for root command\n  type: integer\n  variadic: false\n- name: arg_c\n  description: c - this is an argument for root command\n  type: boolean\n  variadic: false\n- name: arg_d\n  description: d - this is an argument for root command\n  type: float\n  variadic: false\n- name: arg_e\n  description: \"\"\n  type: \"\"\n  variadic: false\n- name: arg_v\n  description: v - this is an argument for root command\n  type: \"\"\n  variadic: true\nsubcommands:\n  sub1:\n    description: 1 - this is a sub command\n    options: {}\n    arguments: []\n    subcommands: {}\n  sub2:\n    description: 2 - this is a sub command\n    options: {}\n    arguments: []\n    subcommands: {}\n  sub3:\n    description: 3 - this is a sub command\n    options:\n      -option-a:\n        short: -a\n        description: 3 - a - this is an option for root command\n        type: string\n        default: abc\n      -option-b:\n        short: -b\n        description: 3 - b - this is an option for root command\n        type: integer\n        default: \"-123\"\n      -option-c:\n        short: -c\n        description: 3 - c - this is an option for root command\n        type: boolean\n        default: \"true\"\n      -option-d:\n        short: -d\n        description: 3 - d - this is an option for root command\n        type: float\n        default: \"-123.456\"\n      -option-e:\n        short: \"\"\n        description: \"\"\n        type: \"\"\n        default: \"\"\n    arguments:\n    - name: arg_a\n      description: 3 - a - this is an argument for root command\n      type: string\n      variadic: false\n    - name: arg_b\n      description: 3 - b - this is an argument for root command\n      type: integer\n      variadic: false\n    - name: arg_c\n      description: 3 - c - this is an argument for root command\n      type: boolean\n      variadic: false\n    - name: arg_d\n      description: 3 - d - this is an argument for root command\n      type: float\n      variadic: false\n    - name: arg_e\n      description: \"\"\n      type: \"\"\n      variadic: false\n    - name: arg_v\n      description: 3 - v - this is an argument for root command\n      type: \"\"\n      variadic: true\n    subcommands:\n      subx:\n        description: \"\"\n        options: {}\n        arguments: []\n        subcommands: {}\n      suby:\n        description: \"\"\n        options: {}\n        arguments: []\n        subcommands: {}\n"))
	return schema
}


type Func[Input any] func(cmdSchema *cliautor_schema.Command, subcommand []string, input Input) (err error)




type CLI struct {
	Sub_Sub1 CLI_Sub1
	Sub_Sub2 CLI_Sub2
	Sub_Sub3 CLI_Sub3

	Func Func[CLI_Input]
}

type CLI_Input struct {
	Opt_OptionA string
	Opt_OptionB int64
	Opt_OptionC bool
	Opt_OptionD float64
	Opt_OptionE string

	Arg_ArgA string
	Arg_ArgB int64
	Arg_ArgC bool
	Arg_ArgD float64
	Arg_ArgE string
	Arg_ArgV []string

}







type CLI_Sub1 struct {

	Func Func[CLI_Sub1_Input]
}

type CLI_Sub1_Input struct {


}



type CLI_Sub2 struct {

	Func Func[CLI_Sub2_Input]
}

type CLI_Sub2_Input struct {


}



type CLI_Sub3 struct {
	Sub_Subx CLI_Sub3Subx
	Sub_Suby CLI_Sub3Suby

	Func Func[CLI_Sub3_Input]
}

type CLI_Sub3_Input struct {
	Opt_OptionA string
	Opt_OptionB int64
	Opt_OptionC bool
	Opt_OptionD float64
	Opt_OptionE string

	Arg_ArgA string
	Arg_ArgB int64
	Arg_ArgC bool
	Arg_ArgD float64
	Arg_ArgE string
	Arg_ArgV []string

}



type CLI_Sub3Subx struct {

	Func Func[CLI_Sub3Subx_Input]
}

type CLI_Sub3Subx_Input struct {


}



type CLI_Sub3Suby struct {

	Func Func[CLI_Sub3Suby_Input]
}

type CLI_Sub3Suby_Input struct {


}




func NewCLI() CLI {
	cli := CLI{}
	s := newSchema()

	cli.Func = cliautor_golang.NewDefaultFunc[CLI_Input](s.Program.Name)


	cli.Sub_Sub1.Func = cliautor_golang.NewDefaultFunc[CLI_Sub1_Input](s.Program.Name)

	cli.Sub_Sub2.Func = cliautor_golang.NewDefaultFunc[CLI_Sub2_Input](s.Program.Name)

	cli.Sub_Sub3.Func = cliautor_golang.NewDefaultFunc[CLI_Sub3_Input](s.Program.Name)

	cli.Sub_Sub3.Sub_Subx.Func = cliautor_golang.NewDefaultFunc[CLI_Sub3Subx_Input](s.Program.Name)

	cli.Sub_Sub3.Sub_Suby.Func = cliautor_golang.NewDefaultFunc[CLI_Sub3Suby_Input](s.Program.Name)

	return cli
}


func Run(cli CLI, args []string) error {
	cmd, subcommand, restArgs := cliautor_golang.ResolveSubcommand(newSchema(), args)
	switch strings.Join(subcommand, " ") {

	case "":
		input := CLI_Input{
			Opt_OptionA: "abc",
			Opt_OptionB: int64(-123),
			Opt_OptionC: true,
			Opt_OptionD: float64(-123.456),
			Opt_OptionE: "",

		}
		if err := cliautor_golang.ResolveInput(cmd, restArgs, &input); err != nil {
			return fmt.Errorf("fail to resolve input: %w", err)
		}
		funcMethod := cli.Func
		if funcMethod == nil {
			return fmt.Errorf("%q is unsupported: cli.Func not assigned", "")
		}
		if err := funcMethod(cmd, subcommand, input); err != nil {
			return fmt.Errorf("cli.Func(input) failed: %w", err)
		}


	case "sub1":
		input := CLI_Sub1_Input{

		}
		if err := cliautor_golang.ResolveInput(cmd, restArgs, &input); err != nil {
			return fmt.Errorf("fail to resolve input: %w", err)
		}
		funcMethod := cli.Sub_Sub1.Func
		if funcMethod == nil {
			return fmt.Errorf("%q is unsupported: cli.Sub_Sub1.Func not assigned", "sub1")
		}
		if err := funcMethod(cmd, subcommand, input); err != nil {
			return fmt.Errorf("cli.Sub_Sub1.Func(input) failed: %w", err)
		}

	case "sub2":
		input := CLI_Sub2_Input{

		}
		if err := cliautor_golang.ResolveInput(cmd, restArgs, &input); err != nil {
			return fmt.Errorf("fail to resolve input: %w", err)
		}
		funcMethod := cli.Sub_Sub2.Func
		if funcMethod == nil {
			return fmt.Errorf("%q is unsupported: cli.Sub_Sub2.Func not assigned", "sub2")
		}
		if err := funcMethod(cmd, subcommand, input); err != nil {
			return fmt.Errorf("cli.Sub_Sub2.Func(input) failed: %w", err)
		}

	case "sub3":
		input := CLI_Sub3_Input{
			Opt_OptionA: "abc",
			Opt_OptionB: int64(-123),
			Opt_OptionC: true,
			Opt_OptionD: float64(-123.456),
			Opt_OptionE: "",

		}
		if err := cliautor_golang.ResolveInput(cmd, restArgs, &input); err != nil {
			return fmt.Errorf("fail to resolve input: %w", err)
		}
		funcMethod := cli.Sub_Sub3.Func
		if funcMethod == nil {
			return fmt.Errorf("%q is unsupported: cli.Sub_Sub3.Func not assigned", "sub3")
		}
		if err := funcMethod(cmd, subcommand, input); err != nil {
			return fmt.Errorf("cli.Sub_Sub3.Func(input) failed: %w", err)
		}

	case "sub3 subx":
		input := CLI_Sub3Subx_Input{

		}
		if err := cliautor_golang.ResolveInput(cmd, restArgs, &input); err != nil {
			return fmt.Errorf("fail to resolve input: %w", err)
		}
		funcMethod := cli.Sub_Sub3.Sub_Subx.Func
		if funcMethod == nil {
			return fmt.Errorf("%q is unsupported: cli.Sub_Sub3.Sub_Subx.Func not assigned", "sub3 subx")
		}
		if err := funcMethod(cmd, subcommand, input); err != nil {
			return fmt.Errorf("cli.Sub_Sub3.Sub_Subx.Func(input) failed: %w", err)
		}

	case "sub3 suby":
		input := CLI_Sub3Suby_Input{

		}
		if err := cliautor_golang.ResolveInput(cmd, restArgs, &input); err != nil {
			return fmt.Errorf("fail to resolve input: %w", err)
		}
		funcMethod := cli.Sub_Sub3.Sub_Suby.Func
		if funcMethod == nil {
			return fmt.Errorf("%q is unsupported: cli.Sub_Sub3.Sub_Suby.Func not assigned", "sub3 suby")
		}
		if err := funcMethod(cmd, subcommand, input); err != nil {
			return fmt.Errorf("cli.Sub_Sub3.Sub_Suby.Func(input) failed: %w", err)
		}

	}
	return nil
}
