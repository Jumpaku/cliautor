// Code generated by {{.Generator}} {{.GeneratorVersion}}, DO NOT EDIT.
package {{.Package}}

import (
	"fmt"
	"bytes"
	"strings"
	"os"

	cliautor_schema "github.com/Jumpaku/cliautor/schema"
	cliautor_golang "github.com/Jumpaku/cliautor/golang"
	cliautor_description "github.com/Jumpaku/cliautor/description"
)

func newSchema() *cliautor_schema.Schema {
	var schema, _ = cliautor_schema.Load(bytes.NewBufferString({{.SchemaYAMLLiteral}}))
	return schema
}


type Func[Input any] func(cmdSchema *cliautor_schema.Command, subcommand []string, input Input) (err error)

{{/* Root command */}}
{{with .Program}}

type {{.CLIStructName}} struct {
{{range $Index, $Subcommand := .Subcommands}}	{{$Subcommand.SubcommandFieldName}} {{$Subcommand.SubcommandFieldType}}
{{end}}
	Func Func[{{.CLIInputStructName}}]
}

type {{.CLIInputStructName}} struct {
{{range $Index, $Option := .Options}}	{{$Option.InputFieldName}} {{$Option.InputFieldType}}
{{end}}
{{range $Index, $Argument := .Arguments}}	{{$Argument.InputFieldName}} {{$Argument.InputFieldType}}
{{end}}
}

{{end}}


{{/* Child commands */}}
{{range .Commands}}

type {{.CLIStructName}} struct {
{{range $Index, $Subcommand := .Subcommands}}	{{$Subcommand.SubcommandFieldName}} {{$Subcommand.SubcommandFieldType}}
{{end}}
	Func Func[{{.CLIInputStructName}}]
}

type {{.CLIInputStructName}} struct {
{{range $Index, $Option := .Options}}	{{$Option.InputFieldName}} {{$Option.InputFieldType}}
{{end}}
{{range $Index, $Argument := .Arguments}}	{{$Argument.InputFieldName}} {{$Argument.InputFieldType}}
{{end}}
}

{{end}}

{{/* CLI Constructor */}}
func NewCLI() {{.Program.CLIStructName}} {
	cli := CLI{}
	s := newSchema()
{{with .Program}}
	cli.{{.CLIFuncMethodChain}} = cliautor_golang.NewDefaultFunc[{{.CLIInputStructName}}](s.Program.Name)
{{end}}
{{range .Commands}}
	cli.{{.CLIFuncMethodChain}} = cliautor_golang.NewDefaultFunc[{{.CLIInputStructName}}](s.Program.Name)
{{end}}
	return cli
}

{{/* Entry point */}}
func Run(cli CLI, args []string) error {
	s := newSchema()
	cmd, subcommand, restArgs := cliautor_golang.ResolveSubcommand(s, args)
	switch strings.Join(subcommand, " ") {
{{with .Program}}
	case {{.NameLiteral}}:
		input := {{.CLIInputStructName}}{
{{range $Index, $Option := .Options}}			{{$Option.InputFieldName}}: {{$Option.DefaultLiteral}},
{{end}}
		}
		if err := cliautor_golang.ResolveInput(cmd, restArgs, &input); err != nil {
			descData := cliautor_description.CreateCommandData(s.Program.Name, subcommand, cmd)
			if err := cliautor_description.DescribeCommand(cliautor_description.SimpleExecutor(), descData, os.Stderr); err != nil {
				panic(fmt.Errorf("fail to create command description: %w", err))
			}
			fmt.Fprintln(os.Stderr, "")
			return fmt.Errorf("fail to resolve input: %w", err)
		}
		funcMethod := cli.{{.CLIFuncMethodChain}}
		if funcMethod == nil {
			return fmt.Errorf("%q is unsupported: cli.{{.CLIFuncMethodChain}} not assigned", {{.NameLiteral}})
		}
		if err := funcMethod(cmd, subcommand, input); err != nil {
			return fmt.Errorf("cli.{{.CLIFuncMethodChain}}(input) failed: %w", err)
		}
{{end}}
{{range .Commands}}
	case {{.NameLiteral}}:
		input := {{.CLIInputStructName}}{
{{range $Index, $Option := .Options}}			{{$Option.InputFieldName}}: {{$Option.DefaultLiteral}},
{{end}}
		}
		if err := cliautor_golang.ResolveInput(cmd, restArgs, &input); err != nil {
			descData := cliautor_description.CreateCommandData(s.Program.Name, subcommand, cmd)
			if err := cliautor_description.DescribeCommand(cliautor_description.SimpleExecutor(), descData, os.Stderr); err != nil {
				panic(fmt.Errorf("fail to create command description: %w", err))
			}
			fmt.Fprintln(os.Stderr, "")
			return fmt.Errorf("fail to resolve input: %w", err)
		}
		funcMethod := cli.{{.CLIFuncMethodChain}}
		if funcMethod == nil {
			return fmt.Errorf("%q is unsupported: cli.{{.CLIFuncMethodChain}} not assigned", {{.NameLiteral}})
		}
		if err := funcMethod(cmd, subcommand, input); err != nil {
			return fmt.Errorf("cli.{{.CLIFuncMethodChain}}(input) failed: %w", err)
		}
{{end}}
	}
	return nil
}
