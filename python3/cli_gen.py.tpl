{{- /* Go Template */ -}}
# Code generated by {{.Generator}} {{.GeneratorVersion}}, DO NOT EDIT.

from dataclasses import dataclass
from typing import TypeAlias
import typing


FuncTypeInput = typing.TypeVar('FuncTypeInput')
FuncType: TypeAlias = typing.Callable[[None,FuncTypeInput,Exception],None]

{{- /* Child commands */}}
{{range .Commands}}

@dataclass
class {{.CLIInputClassName}}:
    {{range $Index, $Option := .Options -}}
    {{$Option.InputFieldName}}: {{$Option.InputFieldType}} = {{$Option.DefaultLiteral}}{{"\n    "}}
    {{- end}}
    {{range $Index, $Argument := .Arguments -}}
    {{$Argument.InputFieldName}}: {{$Argument.InputFieldType}} = {{$Argument.InputFieldType}}(){{"\n    "}}
    {{- end}}
    pass


class {{.CLIClassName}}:
    {{range $Index, $Subcommand := .Subcommands -}}
    {{$Subcommand.SubcommandFieldName}}: {{$Subcommand.SubcommandFieldType}} = {{$Subcommand.SubcommandFieldType}}(){{"\n    "}}
    {{- end}}
    desc_simple: str = {{.SimpleDescriptionLiteral}}
    desc_detail: str = {{.DetailDescriptionLiteral}}
    FUNC: FuncType[{{.CLIInputClassName}}] = None


def resolve_{{.CLIInputClassName}}(rest_args: list[str])->{{.CLIInputClassName}}:
    input = {{.CLIInputClassName}}()
    arguments = []
    for i, arg in enumerate(rest_args):
        if arg == "--":
            arguments += rest_args[i+1:]
            break
        if not arg.startswith("-"):
            arguments.append(arg)
            continue
        split = arg.split("=", 1)
        opt_name, assign = split[0], len(split) > 1
        match opt_name:
        {{range $Index, $Option := .Options}}
            case {{$Option.NameLiteral}}{{if $Option.ShortNameLiteral}} | {{$Option.ShortNameLiteral}}{{end}}:
                if not assign:
                    {{if eq $Option.InputFieldType "bool"}}split[1] = "True"
                    {{else}}raise Exception("value is not specified to option "+ opt_name)
                    {{end}}
                input.{{$Option.InputFieldName}} = parse_value({{$Option.InputFieldType}}, split[1])
        {{end}}
            case _:
                raise Exception("unsupported option " + opt_name)
    {{range $Index, $Argument := .Arguments -}}
    {{- if $Argument.Variadic -}}
    if len(arguments) <= {{$Index}} - 1:
        raise Exception("too few arguments")
    input.{{$Argument.InputFieldName}} = parse_value({{$Argument.InputFieldType}}, arguments[{{$Index}}:])
    {{- else -}}
    if len(arguments) <= {{$Index}}:
        raise Exception("too few arguments")
    input.{{$Argument.InputFieldName}} = parse_value({{$Argument.InputFieldType}}, arguments[{{$Index}}])
    {{- end -}}{{"\n    "}}
    {{- end}}
    return input
{{end}}

{{- /* Root command */}}
{{with .Program}}
@dataclass
class {{.CLIInputClassName}}:
    {{range $Index, $Option := .Options -}}
    {{$Option.InputFieldName}}: {{$Option.InputFieldType}} = {{$Option.DefaultLiteral}}{{"\n    "}}
    {{- end}}
    {{range $Index, $Argument := .Arguments -}}
    {{$Argument.InputFieldName}}: {{$Argument.InputFieldType}} = {{$Argument.InputFieldType}}(){{"\n    "}}
    {{- end}}
    pass


class {{.CLIClassName}}:
    {{range $Index, $Subcommand := .Subcommands -}}
    {{$Subcommand.SubcommandFieldName}}: {{$Subcommand.SubcommandFieldType}} = {{$Subcommand.SubcommandFieldType}}(){{"\n    "}}
    {{- end}}
    desc_simple: str = {{.SimpleDescriptionLiteral}}
    desc_detail: str = {{.DetailDescriptionLiteral}}
    FUNC: FuncType[{{.CLIInputClassName}}] = None


def resolve_{{.CLIInputClassName}}(rest_args: list[str])->{{.CLIInputClassName}}:
    input = {{.CLIInputClassName}}()
    arguments = []
    for i, arg in enumerate(rest_args):
        if arg == "--":
            arguments += rest_args[i+1:]
            break
        if not arg.startswith("-"):
            arguments.append(arg)
            continue
        split = arg.split("=", 1)
        opt_name, assign = split[0], len(split) > 1
        match opt_name:
        {{range $Index, $Option := .Options}}
            case {{$Option.NameLiteral}}{{if $Option.ShortNameLiteral}} | {{$Option.ShortNameLiteral}}{{end}}:
                if not assign:
                    {{if eq $Option.InputFieldType "bool"}}split[1] = "True"
                    {{else}}raise Exception("value is not specified to option "+ opt_name)
                    {{end}}
                input.{{$Option.InputFieldName}} = parse_value({{$Option.InputFieldType}}, split[1])
        {{end}}
            case _:
                raise Exception("unsupported option " + opt_name)
    {{range $Index, $Argument := .Arguments -}}
    {{- if $Argument.Variadic -}}
    if len(arguments) <= {{$Index}} - 1:
        raise Exception("too few arguments")
    input.{{$Argument.InputFieldName}} = parse_value({{$Argument.InputFieldType}}, arguments[{{$Index}}:])
    {{- else -}}
    if len(arguments) <= {{$Index}}:
        raise Exception("too few arguments")
    input.{{$Argument.InputFieldName}} = parse_value({{$Argument.InputFieldType}}, arguments[{{$Index}}])
    {{- end -}}{{"\n    "}}
    {{- end}}
    return input
{{end}}

{{/* Entry point */ -}}
def run(cli: CLI, args: list[str]):
    r = resolve_subcommand(args)
    subcommand_path, rest_args = r.subcommand, r.rest_args
    match " ".join(subcommand_path):
    {{with .Program}}
        case {{.FullPathLiteral}}:
            if not cli.{{.CLIFuncMethodChain}}:
                raise Exception("unsupported subcommand \"" + {{.FullPathLiteral}} + "\": cli.{{.CLIFuncMethodChain}} not assigned")
            ex: Exception = None
            input: {{.CLIInputClassName}} = None
            try:
                input = resolve_{{.CLIInputClassName}}(rest_args)
            except Exception as e:
                ex = e
            cli.{{.CLIFuncMethodChain}}(input, ex)
    {{end}}
    {{range .Commands}}
        case {{.FullPathLiteral}}:
            if not cli.{{.CLIFuncMethodChain}}:
                raise Exception("unsupported subcommand \"" + {{.FullPathLiteral}} + "\": cli.{{.CLIFuncMethodChain}} not assigned")
            ex: Exception = None
            input: {{.CLIInputClassName}} = None
            try:
                input = resolve_{{.CLIInputClassName}}(rest_args)
            except Exception as e:
                ex = e
            cli.{{.CLIFuncMethodChain}}(input, ex)
    {{end}}

@dataclass
class ResolveSubcommandResult:
    subcommand: list[str]
    rest_args: list[str]


def resolve_subcommand(args: list[str])->ResolveSubcommandResult:
    if not args:
        raise Exception("command line arguments are too few")
    
    subcommand_set = {
        {{with .Program}}{{.FullPathLiteral}},{{end}}
        {{range .Commands}}{{.FullPathLiteral}},{{end}}
    }

    subcommand_path = []
    for arg in args[1:]:
        if arg == "--":
            break
        if " ".join(subcommand_path + [arg]) not in subcommand_set:
            break
        subcommand_path.append(arg)
    
    return ResolveSubcommandResult(subcommand_path, args[1+len(subcommand_path):])


def parse_value(typ, *strValues: str) -> str | bool | float | int | tuple[str,...] | tuple[bool,...] | tuple[float,...] | tuple[int,...]:
    try: 
        if typ == str:
            return str(strValues[0])
        if typ == bool:
            if strValues[0] in {"", "0", "f", "F", "FALSE", "false", "False"}:
                return False
            if strValues[0] in {"1", "t", "T", "TRUE", "true", "True"}:
                return False
            raise Exception("could not convert string to bool: '" + strValues[0] + "'")
        if typ == float:
            return float(strValues[0])
        if typ == int:
            return int(strValues[0], base=0)
        if typ == tuple[str,...]:
            return tuple([parse_value(str, s) for s in strValues])
        if typ == tuple[bool,...]:
            return tuple([parse_value(bool, s) for s in strValues])
        if typ == tuple[float,...]:
            return tuple([parse_value(float, s) for s in strValues])
        if typ == tuple[int,...]:
            return tuple([parse_value(int, s) for s in strValues])
        raise Exception("unsupported type")
    except Exception as e:
        e.add_note('fail to parse string value as ' + typ.__name__)
        raise
