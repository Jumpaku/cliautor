package main

import (
	"bytes"
	"fmt"
	"github.com/Jumpaku/cyamli/docs"
	"github.com/Jumpaku/cyamli/name"
	"github.com/Jumpaku/cyamli/schema"
	"log"
	"os"
)

//go:generate go run "github.com/Jumpaku/cyamli/cmd/cyamli@v0.0.15" generate golang -package=main -schema-path=cli.yaml -out-path=cli.gen.go

func main() {
	cli := NewCLI()
	cli.FUNC = func(subcommand []string, input CLI_Input, inputErr error) (err error) {
		if inputErr != nil {
			return fmt.Errorf("invalid argument: %w", inputErr)
		}

		in, err := os.Open(input.Arg_Schema)
		if err != nil {
			log.Panicln(err)
		}
		defer in.Close()

		s, err := schema.Load(in)
		if err != nil {
			log.Panicln(err)
		}

		out, err := os.Create(input.Arg_OutPath)
		if err != nil {
			log.Panicln(err)
		}
		defer out.Close()

		if _, err := fmt.Fprintf(out, `// Code generated by github.com/Jumpaku/cyamli/internal/cmd/gen-docs@v0.0.15, DO NOT EDIT.
package %s

`, input.Arg_Package); err != nil {
			log.Panicln(err)
		}
		err = s.Walk(func(path name.Path, cmd *schema.Command) error {
			buf := bytes.NewBuffer(nil)
			err = docs.Generate(s, docs.GenerateArgs{Format: docs.DocsFormatText, Subcommand: path}, buf)
			if err != nil {
				return fmt.Errorf(`fail to write: %w`, err)
			}

			varName := append(name.Path{"cyamli"}, path...).Join("_", "DocText_", "")
			if _, err := fmt.Fprintf(out, `var %s = %q
`, varName, buf.String()); err != nil {
				return fmt.Errorf(`fail to write to %q: %w`, out.Name(), err)
			}

			return nil
		})
		if err != nil {
			log.Panicln(err)
		}

		return nil
	}

	if err := Run(cli, os.Args); err != nil {
		log.Panicln(err)
	}
}
